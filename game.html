<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Baccarat – Rock • Paper • Scissors • Joker</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #161a2b;
      --accent: #7c5cff;
      --accent-2: #00d2ff;
      --text: #ecf0ff;
      --muted: #a7b0d6;
      --win: #20c997;
      --lose: #ff6b6b;
      --tie: #ffd43b;
      --card-bg: linear-gradient(135deg, #1c2242, #282f5b);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
      Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; color: var(--text);
      background: radial-gradient(1200px 800px at 20% 10%, #1c2242 0%, #0f1220 50%, #0b0e19 100%);
      min-height: 100svh; display: grid; place-items: center; padding: clamp(12px, 3vw, 24px);
    }
    .app { width: min(1100px, 96vw); }
    .panel {
      background: color-mix(in oklab, var(--panel), transparent 5%);
      border: 1px solid color-mix(in oklab, var(--accent), transparent 80%);
      border-radius: 20px; padding: clamp(12px, 2vw, 18px) clamp(12px, 2vw, 18px) 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35); backdrop-filter: blur(6px);
    }
    h1 { margin: 0 0 6px; font-size: clamp(18px, 3vw, 26px); letter-spacing: .2px; }
    p, li { color: var(--muted); font-size: clamp(12px, 1.8vw, 14px); }

    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .row { grid-template-columns: 1.2fr .8fr; } }
    @media (max-width: 600px) { .row { gap: 8px; } }

    .board { display: grid; gap: 12px; }
    .lane { display: grid; grid-template-columns: 100px 1fr; align-items: center; gap: 12px; }
    @media (max-width: 600px) { .lane { grid-template-columns: 80px 1fr; gap: 8px; } }
    .label { font-weight: 700; letter-spacing: .5px; text-transform: uppercase; color: var(--muted); opacity: .9; font-size: clamp(12px, 1.8vw, 14px); }

    .cards { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; min-height: 90px; }
    .card { width: 80px; height: 108px; border-radius: 12px; background: var(--card-bg); border: 1px solid rgba(255,255,255,.08);
      display: grid; place-items: center; font-size: 36px; position: relative; box-shadow: 0 8px 16px rgba(0,0,0,.25);
      transform: translateY(0); transition: transform .15s ease, box-shadow .15s ease; }
    .card:hover { transform: translateY(-2px); box-shadow: 0 12px 22px rgba(0,0,0,.32); }
    @media (max-width: 600px) { .card { width: 64px; height: 86px; font-size: 28px; } }
    .ghost { opacity: .28; border-style: dashed; }

    .status { font-weight: 800; letter-spacing: .6px; text-transform: uppercase; font-size: clamp(12px, 1.8vw, 14px); }
    .status.win { color: var(--win); }
    .status.lose { color: var(--lose); }
    .status.tie { color: var(--tie); }

    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      background: linear-gradient(180deg, color-mix(in oklab, var(--accent), white 12%), var(--accent));
      color: white; border: 0; padding: 10px 14px; border-radius: 12px; font-weight: 700; cursor: pointer;
      box-shadow: 0 6px 16px rgba(124,92,255,.35); transition: transform .08s ease, box-shadow .12s ease, opacity .15s ease;
      min-height: 48px; font-size: clamp(12px, 1.8vw, 14px); touch-action: manipulation;
    }
    button.secondary { background: #262c4f; box-shadow: 0 5px 12px rgba(0,0,0,.25); }
    button.ghost { background: transparent; border: 1px solid #343b6b; color: var(--muted); box-shadow: none; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    button.active { background: linear-gradient(180deg, color-mix(in oklab, var(--win), white 12%), var(--win)); box-shadow: 0 6px 16px rgba(32,201,151,.35); }
    .kpi { display: grid; grid-auto-flow: column; gap: 12px; align-items: center; }
    .pill { background: #1a1f3f; border: 1px solid #2a3171; border-radius: 999px; padding: 6px 10px; font-weight: 700; font-size: clamp(12px, 1.8vw, 14px); }

    .right { display: grid; gap: 12px; }
    .stack { display: grid; gap: 8px; }
    .history { max-height: 280px; overflow: auto; border-radius: 12px; border: 1px solid #29306a; background: rgba(18,22,42,.6); }
    .history table { width: 100%; border-collapse: collapse; font-size: clamp(11px, 1.6vw, 12px); }
    .history th, .history td { padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,.06); }
    .history tr:last-child td { border-bottom: 0; }
    @media (max-width: 600px) {
      .history { overflow-x: auto; }
      .history table { min-width: 400px; }
    }
    .tag { padding: 2px 8px; border-radius: 999px; font-weight: 800; font-size: clamp(10px, 1.5vw, 11px); text-transform: uppercase; letter-spacing: .4px; }
    .tag.win { background: color-mix(in oklab, var(--win), transparent 80%); color: var(--win); }
    .tag.lose { background: color-mix(in oklab, var(--lose), transparent 80%); color: var(--lose); }
    .tag.tie { background: color-mix(in oklab, var(--tie), transparent 80%); color: var(--tie); }

    .small { font-size: clamp(10px, 1.5vw, 11px); color: var(--muted); }
    .rules { line-height: 1.5; }
    .divider { height: 1px; background: rgba(255,255,255,.08); margin: 6px 0 0; }
    .deckbar { height: 6px; background: #22284a; border-radius: 999px; overflow: hidden; }
    .deckbar > div { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); width: 100%; }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Mini Baccarat – <span style="opacity:.85">Rock • Paper • Scissors • Joker</span></h1>
      <div class="row">
        <div class="board">
          <div class="lane">
            <div class="label">Player</div>
            <div class="cards" id="player-cards">
              <div class="card ghost">🃏</div>
              <div class="card ghost">🃏</div>
            </div>
          </div>
          <div class="lane">
            <div class="label">Banker</div>
            <div class="cards" id="banker-cards">
              <div class="card ghost">🃏</div>
              <div class="card ghost">🃏</div>
            </div>
          </div>

          <div style="display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap;">
            <div class="kpi">
              <div class="pill" aria-live="polite">Lives: <span id="lives">3</span></div>
              <div class="pill" aria-live="polite">Deck: <span id="deck-count">38</span> cards</div>
              <div class="pill status" id="round-status" aria-live="polite">Ready</div>
            </div>
            <div class="controls">
              <button class="secondary" id="bet-player" tabindex="0" aria-label="Bet on Player to win">Bet Player</button>
              <button class="secondary" id="bet-banker" tabindex="0" aria-label="Bet on Banker to win">Bet Banker</button>
              <button class="secondary" id="bet-tie" tabindex="0" aria-label="Bet on a Tie">Bet Tie</button>
              <button id="deal" tabindex="0" aria-label="Deal a new hand">Deal Hand</button>
              <button class="secondary" id="reshuffle" tabindex="0" aria-label="Reshuffle the deck">Reshuffle</button>
              <button class="ghost" id="reset" tabindex="0" aria-label="Reset the game to default state">Reset Game</button>
            </div>
          </div>

          <div class="deckbar"><div id="deckbar-fill"></div></div>
        </div>

        <div class="right">
          <div class="stack rules">
            <strong>Rules (your custom variant)</strong>
            <ul>
              <li>Deck: <strong>38 cards</strong> — 8 Jokers, 10 Rock, 10 Paper, 10 Scissors.</li>
              <li>Each side is dealt <strong>two cards</strong>.</li>
              <li><strong>Two Jokers</strong> = automatic win for that side. If both have two Jokers → tie.</li>
              <li>One Joker + one symbol → the hand becomes that <em>symbol</em>.</li>
              <li>Pair of the same symbol → the hand becomes that <em>symbol</em>.</li>
              <li>Two different symbols → reduce using RPS: Rock beats Scissors, Scissors beats Paper, Paper beats Rock.</li>
              <li>Compare Player vs Banker results: winning symbol takes the hand; same symbol → tie.</li>
              <li><strong>Betting</strong>: Before each hand, bet 1 life on Player, Banker, or Tie. If wrong, lose 1 life.</li>
              <li>If correct: Player bet gains +0.5 life, Banker +1 life, Tie +2 lives (net).</li>
              <li>Start with 3 lives. Max lives: 7.</li>
            </ul>
          </div>

          <div class="stack">
            <strong>History</strong>
            <div class="history">
              <table>
                <thead>
                  <tr><th>#</th><th>Bet</th><th>Player</th><th>Banker</th><th>Result</th><th>Δ Lives</th></tr>
                </thead>
                <tbody id="log" aria-live="polite"></tbody>
              </table>
            </div>
            <div class="small">Tip: The deck auto-reshuffles when it runs low. Use <em>Reset Game</em> to return to defaults or <em>Reshuffle</em> to keep your lives but refresh the deck.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Card & Deck model ----------------------------------------------------
    const EMOJI = { R: '🪨', P: '📄', S: '✂️', J: '🃏' };
    const NAME  = { R: 'Rock', P: 'Paper', S: 'Scissors', J: 'Joker' };

    function makeDeck(){
      const deck = [];
      for(let i=0;i<10;i++){ deck.push('R','P','S'); } // 30 cards, 10 each
      for(let j=0;j<8;j++){ deck.push('J'); }           // 8 jokers → 38 total
      return shuffle(deck);
    }

    function shuffle(arr){
      // Fisher-Yates
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // Evaluate a two-card hand to its effective type
    function evalHand([c1, c2]){
      if(c1==='J' && c2==='J') return { type: 'JJ', label: 'Double Joker' };
      if(c1==='J' && c2!=='J') return { type: c2, label: NAME[c2] };
      if(c2==='J' && c1!=='J') return { type: c1, label: NAME[c1] };
      if(c1===c2) return { type: c1, label: NAME[c1] };
      // Different non-jokers → resolve via RPS dominance
      const beats = { R: 'S', S: 'P', P: 'R' };
      const winner = beats[c1]===c2 ? c1 : c2; // if c1 beats c2 → c1 else c2 beats c1
      return { type: winner, label: NAME[winner] };
    }

    // Compare two evaluated hands; return 'player' | 'banker' | 'tie'
    function compareHands(p, b){
      if(p.type==='JJ' && b.type==='JJ') return 'tie';
      if(p.type==='JJ') return 'player';
      if(b.type==='JJ') return 'banker';
      if(p.type===b.type) return 'tie';
      const beats = { R: 'S', S: 'P', P: 'R' };
      return beats[p.type]===b.type ? 'player' : 'banker';
    }

    // --- Game state -----------------------------------------------------------
    let deck = makeDeck();
    let lives = 3;
    let handNo = 0;
    let currentBet = null;

    const els = {
      pCards: document.getElementById('player-cards'),
      bCards: document.getElementById('banker-cards'),
      lives: document.getElementById('lives'),
      deckCount: document.getElementById('deck-count'),
      status: document.getElementById('round-status'),
      log: document.getElementById('log'),
      deckbar: document.getElementById('deckbar-fill'),
      deal: document.getElementById('deal'),
      reshuffle: document.getElementById('reshuffle'),
      reset: document.getElementById('reset'),
      betPlayer: document.getElementById('bet-player'),
      betBanker: document.getElementById('bet-banker'),
      betTie: document.getElementById('bet-tie'),
    };

    function updateDeckUI(){
      els.deckCount.textContent = deck.length;
      const pct = Math.max(0, Math.min(100, (deck.length/38)*100));
      els.deckbar.style.width = pct + '%';
    }

    function updateLivesUI(){
      els.lives.textContent = Number.isInteger(lives) ? lives : lives.toFixed(1);
      if (lives < 1) {
        els.deal.disabled = true;
        setStatus('Game Over – Not enough lives', 'lose');
      } else {
        els.deal.disabled = false;
      }
    }

    function renderCards(node, cards){
      node.innerHTML = '';
      cards.forEach(c => {
        const div = document.createElement('div');
        div.className = 'card';
        div.textContent = EMOJI[c];
        node.appendChild(div);
      });
    }

    function renderSingleCard(node, card, index){
      const div = document.createElement('div');
      div.className = 'card';
      div.textContent = EMOJI[card];
      if (node.children[index]) {
        node.replaceChild(div, node.children[index]);
      } else {
        node.appendChild(div);
      }
    }

    function appendLog(pCards, bCards, bet, outcome, delta){
      handNo += 1;
      const tr = document.createElement('tr');
      const fmt = cs => cs.map(c=>EMOJI[c]).join(' ');
      const deltaSign = delta > 0 ? '+' : '';
      const deltaClass = delta > 0 ? 'win' : delta < 0 ? 'lose' : 'tie';
      const resultText = outcome === 'player' ? 'Player' : outcome === 'banker' ? 'Banker' : 'Tie';
      const resultClass = outcome === bet ? 'win' : 'lose';
      tr.innerHTML = `
        <td style="opacity:.8">${handNo}</td>
        <td>${bet.charAt(0).toUpperCase() + bet.slice(1)}</td>
        <td>${fmt(pCards)}</td>
        <td>${fmt(bCards)}</td>
        <td><span class="tag ${resultClass}">${resultText}</span></td>
        <td><span class="tag ${deltaClass}">${deltaSign}${delta}</span></td>
      `;
      els.log.prepend(tr);
    }

    function setStatus(text, cls){
      els.status.className = 'pill status' + (cls ? ' ' + cls : '');
      els.status.textContent = text;
    }

    function ensureDeck(nNeeded){
      if(deck.length < nNeeded){
        deck = makeDeck();
        updateDeckUI();
        setStatus('Auto-reshuffle', 'tie');
      }
    }

    function deal(){
      if (!currentBet) {
        setStatus('Select a bet first', '');
        return;
      }
      if (lives < 1) {
        setStatus('Not enough lives to bet', 'lose');
        return;
      }
      ensureDeck(4);
      lives -= 1;
      updateLivesUI();
      const pCards = [deck.pop(), deck.pop()];
      const bCards = [deck.pop(), deck.pop()];
      updateDeckUI();

      // Disable deal button during animation to prevent multiple clicks
      els.deal.disabled = true;

      // Reset to ghost cards
      els.pCards.innerHTML = '<div class="card ghost">🃏</div><div class="card ghost">🃏</div>';
      els.bCards.innerHTML = '<div class="card ghost">🃏</div><div class="card ghost">🃏</div>';

      // Reveal cards one by one
      setTimeout(() => {
        setStatus('Revealing Player card 1...', '');
        renderSingleCard(els.pCards, pCards[0], 0);
        setTimeout(() => {
          setStatus('Revealing Player card 2...', '');
          renderSingleCard(els.pCards, pCards[1], 1);
          setTimeout(() => {
            setStatus('Revealing Banker card 1...', '');
            renderSingleCard(els.bCards, bCards[0], 0);
            setTimeout(() => {
              setStatus('Revealing Banker card 2...', '');
              renderSingleCard(els.bCards, bCards[1], 1);
              setTimeout(() => {
                const pEval = evalHand(pCards);
                const bEval = evalHand(bCards);
                const who = compareHands(pEval, bEval);

                let delta = -1;
                let reward = 0;
                let statusText = '';
                let statusCls = '';
                if (who === 'player') {
                  statusText = 'Player Wins (' + pEval.label + ' beats ' + bEval.label + ')';
                  statusCls = 'win';
                } else if (who === 'banker') {
                  statusText = 'Banker Wins (' + bEval.label + ' beats ' + pEval.label + ')';
                  statusCls = 'lose';
                } else {
                  statusText = 'Tie (' + pEval.label + ')';
                  statusCls = 'tie';
                }

                if (currentBet === who) {
                  reward = who === 'player' ? 0.5 : who === 'banker' ? 1 : 2;
                  delta = reward;
                  lives += 1 + reward;
                  lives = Math.min(7, lives);
                  statusText += ' | Correct bet! +' + reward + ' lives';
                  statusCls = 'win';
                } else {
                  statusText += ' | Wrong bet, -1 life';
                }
                updateLivesUI();
                setStatus(statusText, statusCls);

                appendLog(pCards, bCards, currentBet, who === 'player' ? 'player' : who === 'banker' ? 'banker' : 'tie', delta);

                // Reset bet selection and re-enable deal button
                currentBet = null;
                [els.betPlayer, els.betBanker, els.betTie].forEach(b => b.classList.remove('active'));
                els.deal.disabled = false;
              }, 625); // Delay after banker card 2
            }, 625); // Delay after banker card 1
          }, 625); // Delay after player card 2
        }, 625); // Delay after player card 1
      }, 0); // Start immediately
    }

    function reshuffle(){
      deck = makeDeck();
      updateDeckUI();
      setStatus('Reshuffled deck', 'tie');
    }

    function reset(){
      deck = makeDeck(); updateDeckUI();
      lives = 3; updateLivesUI();
      handNo = 0; els.log.innerHTML = '';
      currentBet = null;
      [els.betPlayer, els.betBanker, els.betTie].forEach(b => b.classList.remove('active'));
      setStatus('Ready');
      // Reset ghost placeholders
      document.getElementById('player-cards').innerHTML = '<div class="card ghost">🃏</div><div class="card ghost">🃏</div>';
      document.getElementById('banker-cards').innerHTML = '<div class="card ghost">🃏</div><div class="card ghost">🃏</div>';
    }

    // Wire up bet buttons
    els.betPlayer.addEventListener('click', () => {
      [els.betPlayer, els.betBanker, els.betTie].forEach(b => b.classList.remove('active'));
      els.betPlayer.classList.add('active');
      currentBet = 'player';
      setStatus('Bet on Player', '');
    });
    els.betBanker.addEventListener('click', () => {
      [els.betPlayer, els.betBanker, els.betTie].forEach(b => b.classList.remove('active'));
      els.betBanker.classList.add('active');
      currentBet = 'banker';
      setStatus('Bet on Banker', '');
    });
    els.betTie.addEventListener('click', () => {
      [els.betPlayer, els.betBanker, els.betTie].forEach(b => b.classList.remove('active'));
      els.betTie.classList.add('active');
      currentBet = 'tie';
      setStatus('Bet on Tie', '');
    });

    // Wire up other buttons
    els.deal.addEventListener('click', deal);
    els.reshuffle.addEventListener('click', reshuffle);
    els.reset.addEventListener('click', reset);

    // Keyboard navigation
    [els.betPlayer, els.betBanker, els.betTie, els.deal, els.reshuffle, els.reset].forEach(btn => {
      btn.addEventListener('keydown', e => {
        if (e.key === 'Enter') btn.click();
      });
    });

    // Touch support for mobile
    [els.betPlayer, els.betBanker, els.betTie, els.deal, els.reshuffle, els.reset].forEach(btn => {
      btn.addEventListener('touchstart', e => {
        e.preventDefault(); // Prevent double-tap zoom
        btn.click();
      });
    });

    // Initial draw of deck status
    updateDeckUI();
    updateLivesUI();
  </script>
</body>
</html>
